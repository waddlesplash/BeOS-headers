/***************************************************************************
//
//	File:			render2/IRender.h
//
//	Description:	Abstract drawing interface.
//
//	Copyright 2001, Be Incorporated, All Rights Reserved.
//
***************************************************************************/

#ifndef _RENDER2_RENDER_H_
#define _RENDER2_RENDER_H_

#include <math.h>
#include <support2/Binder.h>
#include <render2/Color.h>
#include <render2/Gradient.h>
#include <render2/Point.h>
#include <render2/Rect.h>
#include <render2/RenderDefs.h>
#include <render2/Path.h>
#include <render2/IVisual.h>
#include <raster2/RasterDefs.h>

namespace B {
namespace Render2 {

using namespace Support2;
using namespace Raster2;

class BFont;

/**************************************************************************************/

/*! Rendering is modelled very explicitly as a definition of the value of every pixel
	within the target area. The API provides a small number of primitives to modify
	the current pixel values, and allows more complex rendering to be done by
	compositing multiple operations.
	
	There are basically two types of drawing primitives: parametric drawing operations
	(path definition, stroking, and filling) and raster drawing operations (blitting).
	In the context of this model, it sometimes makes sense to think about these
	respectively as	"sparse" vs. "dense" definitions of pixel values.
	
	Parametric drawing looks very much like Postscript.  All drawing of parametric
	shapes is modelled as incremental building of a complex path with lines, arcs and
	bezier curves.  This path can have numerous disjoint subpaths.  Any of these
	subpaths can be "stroked" using standard Postscript line capping and joining modes
	to form	more complex paths.  Once a path is completely defined, it can be filled.
	A path can be filled with white (1,1,1,1), a solid color, a linear color
	gradient or a bitmap.
	
	Raster drawing is very simple. A call to BeginPixelBlock establishes the pixel
	grid within	which I wish to define samples. This is followed by one or more calls
	to PlacePixels which defines blocks of pixels within that grid. EndPixelBlock ends the
	definition of samples within the grid (undefined pixels are assumed to be (0,0,0,0)).
	
	In addition, general 2D transformations and color-space transformations are available.
	2D transformations operate on vertices as they are passed into the path generation calls, and
	color-space transformations apply at the time of a Fill(), or Paint() call.
	Both of these transformations are composited with the current transformation stack.
	
	State saving and restoring is accomplished with PushState()/PopState(). State includes
	the current 2D and color-space transformations, the current font, stroke style, winding
	rule, the current color or gradient and the current path.
	
	Normal rendering involves compositing, using standard alpha blending, any pixels
	generated with these primitives with the current value of each pixel (i.e. the current
	contents of the framebuffer).  Compositions can also be generated by placing normal
	rendering commands within a BeginGroup()/EndGroup() block. These pixel values
	are pushed onto the transformation stack as position-variant diagonal color
	transformations (i.e. modulations). In other words, any pixel generated from that point
	forward (until a PopState() restores some earlier state) is multiplied by the pixel
	generated by the modulation block. Any number of modulation blocks can be placed onto
	the stack, and modulations can be nested.
	
	Note that the implementation of a given composition can be highly optimized depending on
	its contents and the hardware available.  On the one hand, simple clipping is modelled as the
	modulation of an arbitrary white shape with some later drawing, but can be optimized easily to
	use our standard region-based clipping in most cases.  On the other hand, the effect of a
	modulation block is equivalent to that of the GL "modulate" texture environment, and the
	effect of multiple modultation blocks stacked on top of one another is supported directly by the
	ARB GL multitexture extension.
*/

/**************************************************************************************/

class IRender : public IPath
{
	public:

		B_DECLARE_META_INTERFACE(Render);

		/*! Flags for the Branch() call */
		enum {
			B_SYNCHRONOUS = 0,	//!< Used to create a synchronous branch
			B_ASYNCHRONOUS = 1	//!< Used to create an asynchronous branch
		};

		/*! This structure is used to define the stippling pattern
			\sa SetStippling
		*/
		struct stipple_t {
			coord 	on;			//!< Defines the active length of the path
			coord	off;		//!< Defines the inactive length of the path
		};


		/*! Create a new IRender from the current one. The new IRender
			inherits the current rendering state.
			If B_SYNCHRONOUS is specified drawing order is maintained.
		*/
		virtual	IRender::ptr	Branch(uint32 flags = B_SYNCHRONOUS) = 0;

		/*! Blocks until all pending drawing commands are completed.
			Use carefully, generaly usefull for debugging purpose only.
		*/
		virtual	void			Sync() = 0;

		/*!	Drawing an IVisual. The path is cleared after this call. */
		virtual	void			DisplayVisual(const IVisual::sptr& view, uint32 flags=0, int32 cache_id=-1) = 0;
		virtual	void			DisplayCached(const IVisual::sptr& view, uint32 flags, int32 cache_id);

		/*! Apply the rendering flags. You cannot modify a flags that has been
			previously set. The render_flags are part of render state and as such
			are saved/restored with PushState() and PopState().
			\sa render_flags
		*/
		virtual	void			ApplyFlags(uint32 flags, uint32 which) = 0;


		/*!	An extension of the path-building interface, TextAt() is equivalent to "charpath".
			TextAt() paints the generated path current set color or gradient.
			Text() is more a convenience call, it generates the text at B_ORIGIN.
		*/

		virtual	void			TextAt(	const BPoint&,
										const char *text,
										int32 len=B_CSTR_LEN,
										const escapements& escapements = B_NO_ESCAPEMENT) = 0;

		virtual	void			Text(	const char *text,
										int32 len = B_CSTR_LEN,
										const escapements& escapements = B_NO_ESCAPEMENT);

		/*!	Composite path operations.
			These operate on the current sub-path,
			replacing it with a new path derived from the old one.
		*/

		/*! Stroke() is equivalent to postscript's "strokepath" function.
			Note that when you fill the path generated by Stroke() you use
			the appropriate winding rule.
		*/
		virtual	void			Stroke() = 0;

		/*!	TextToPath() replaces the current sub-path with the path of the given glyphs
			rendered along the former sub-path.
		*/
		virtual	void			TextOnPath(	const char *text,
											int32 len = B_CSTR_LEN,
											const escapements& escapements = B_NO_ESCAPEMENT,
											uint32 flags = B_JUSTIFY_LEFT|B_VALIGN_BASELINE) = 0;

		/*!	Path generation state */
		virtual	void			SetFont(const BFont &font) = 0;			//!< effective at time of Text*() call
		virtual	void			SetWindingRule(winding_rule rule) = 0;	//!< effective at time of Fill()/Paint() call


		/*! These settings are effective at time of Stroke() call */
		//{@
		virtual void			SetPenSize(coord penWidth) = 0;			//!< sets the pen size used for Stroke()
		virtual void			SetCaps(cap_mode start_cap,				//!< capping used for the first end of a subpath
										cap_mode end_cap) = 0;			//!< capping used for the last end of a subpath
		inline	void			SetCaps(cap_mode caps);					//!< sets the capping for both the first and last end
		virtual void			SetJoin(join_mode join,					//!< joining used between segments when stroking
								float mitter_limit=10.0f) = 0;			//!< mitter limit used for B_MITTER_JOIN
		virtual void			SetStippling(							//!< Stippling pattern array terminated by {0,0}.
										const stipple_t *stippling=NULL,
										int32 offset = 0) = 0;			//!< Initial offset in the the array
		//@}

		/*!	Sets the color or gradient used with Paint() */
		virtual void			SetColor(const BColor&) = 0;
		virtual void			SetGradient(const BGradient&) = 0;

		/*!	Path filling. The path is cleared after these call. */
		virtual	void			Fill() = 0;								//!< Fills the path in white
		virtual void			Paint() = 0;							//!< Fills the path with the current color or gradient

		/*!	Transformation stacks
			Changing the 2D tranformation while a path is being constructed
			produce undefined results.
		*/
		virtual	void			Transform(const B2dTransform&) = 0;
		
		/*! The color transformation is effective at time of Fill() or Paint()
			and doesn't apply to pixel blocks. It transforms the current
			color or gradient. \sa SetColor(), \sa SetGradient()
		*/
		virtual	void			Transform(const BColorTransform&) = 0;

		/*!	Grouping of drawing commands */
		virtual	void			BeginGroup(uint32 flags = 0) = 0;		//!< use group_flags here
		virtual	void			EndGroup() = 0;

		/*!	Save/restore state */
		virtual	void			PushState() = 0;
		virtual	void			PopState() = 0;

		/*!	Pixmap/sample support */
		virtual	void			BeginPixelBlock(const BPixelDescription& pixels) = 0;
		virtual	void			PlacePixels(const BRasterPoint& at, const BPixelData& pixels) = 0;
		virtual	void			EndPixelBlock() = 0;

		// deprecated
		inline void SetStrokeStyle(coord penWidth, cap_mode sc=B_BUTT_CAP, cap_mode ec=B_BUTT_CAP,join_mode j=B_BEVEL_JOIN, float m=10.0f);
		inline void SetStrokeStyle(coord penWidth, cap_mode c=B_BUTT_CAP, join_mode j=B_BEVEL_JOIN, float m=10.0f);
};

inline void IRender::SetCaps(cap_mode caps) {
	SetCaps(caps, caps);
}
inline void IRender::SetStrokeStyle(coord penWidth, cap_mode sc, cap_mode ec,join_mode j, float m) {
	SetPenSize(penWidth);
	SetCaps(sc,ec);
	SetJoin(j,m);
}
inline void IRender::SetStrokeStyle(coord penWidth, cap_mode c, join_mode j, float m) {
	SetPenSize(penWidth);
	SetCaps(c,c);
	SetJoin(j,m);
}

} } // namespace B::Render2

#endif	// _RENDER2_RENDER_H_
